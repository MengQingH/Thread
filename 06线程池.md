## 线程池
线程池是一种**基于池化思想管理线程的工具**，经常出现在多线程服务器中，如MySQL。
线程过多会带来额外的开销，其中包括创建销毁线程的开销、调度线程的开销等等，同时也降低了计算机的整体性能。线程池维护多个线程，等待监督管理者分配可并发执行的任务。使用线程池可以代码一系列好处：
* **降低资源消耗**：通过池化技术重复利用已创建的线程，降低线程创建和销毁带来的损耗。
* **提高响应速度**：任务到达时，无需等待线程即可立即执行。
* **提高线程的可管理性**：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。
* **提供更多更强大的功能**：线程池具备可拓展性，允许开发人员向其中增加更多的功能。

## 线程池解决的问题
线程池解决的核心问题就是**资源管理问题**。在并发环境下，系统不能够确定在任意时刻中，有多少任务需要执行，有多少资源需要投入。这种不确定性将带来一下若干问题：
1. 频繁申请、销毁和调度资源，将带来额外消耗。
2. 对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。
3. 系统无法合理管理内部的资源分布，会降低系统的稳定性。
为了解决资源分配这个问题，线程池采用池化的思想。**池化**，顾名思义，是为了最大化收益并最小化风险，而将资源统一在一起管理的一种思想。

# 线程池的核心设计与实现
## 总体设计
Java中的线程池核心实现类是**ThreadPoolExecutor**，ThreadPoolExecutor的UML类图如图所示：
<br><img src=img/ThreadPoolExecutorUML.png><br>ThreadPoolExecutor UML类图<br>

ThreadPoolExecutor的顶层接口是Executor，源码如下：
```java
public interface Executor {
    void execute(Runnable command);
}
```
顶层接口Executor提供了一种思想：**将任务提交和任务执行进行解耦**。**用户无需关注如何创建线程，如何调度线程来执行任务**，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。

ExecutorService接口增加了一些功能：扩充任务的能力，补充可以为一个或一批异步任务生成Future的方法；提供了管控线程池的方法，比如停止线程池的运行。

AbstractExecutorService是上层的抽象类，将执行任务的流程串联起来，保证下层的实现只需关注一个执行任务的方法即可。

最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面**维护自身的生命周期**，另一方面**同时管理线程和任务**，使两者良好的结合从而执行并行任务。

ThreadPoolExecutor运行，同时维护线程和执行任务的运行机制如下图所示：
<br><img src=img/ThreadPoolExecutor运行流程.png><br>
线程池在内部实际上构建了一个**生产者消费者模型**，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。**任务管理部分充当生产者的角色**，当任务提交后，线程池会判断该任务后续的流转：
1. 直接申请线程执行该任务
2. 缓冲到队列中等待线程执行
3. 拒绝该任务
**线程管理部分是消费者**，他们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。

## 生命周期管理
线程池运行的状态，并不是用户显示设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用**一个变量维护两个值**：**运行状态(runState)**和**线程数量(workerCount)**。在具体实现中，线程池将运行状态、线程数量两个关键参数维护在了一起，如下代码所示：
```java
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
```
<kbd>ctl</kbd>这个AtomicInteer类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段，它同时包含两部分的信息，线程池的运行状态(runState)和线程池内有效线程的数量(workerCount)，高三位保存runState，低29位保存workerCount，两个变量互不干扰。
**用一个变量去存储两个值，可以避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源**。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。
线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。
线程池相关的源码如下所示：
```java
//
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
//Integer.SIZE表示以二进制补码形式表示int值的位数，Integer.SIZE-3 = 29 去掉表示运行状态的前三位，表示标识有效线程数量的位数
private static final int COUNT_BITS = Integer.SIZE - 3;
//1左移29位再减1，表示前29位的最大值
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

//使用高三位来表示运行状态
private static final int RUNNING    = -1 << COUNT_BITS;
private static final int SHUTDOWN   =  0 << COUNT_BITS;
private static final int STOP       =  1 << COUNT_BITS;
private static final int TIDYING    =  2 << COUNT_BITS;
private static final int TERMINATED =  3 << COUNT_BITS;

// Packing and unpacking ctl
//返回当前的运行状态
private static int runStateOf(int c)     { return c & ~CAPACITY; }
//返回当前的线程数量
private static int workerCountOf(int c)  { return c & CAPACITY; }
//对runState和workerCount作与操作，把两个值放到一个字段中保存。
private static int ctlOf(int rs, int wc) { return rs | wc; }
```
ThreadPoolExecutor的运行状态一共有5种，分别为：
|运行状态    |状态描述|
|-------    |-------|
|**RUNNING**    |能接受新任务，并且也能处理阻塞队列中的任务|
|**SHUTDOWN**   |关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务|
|**STOP**       |不能接受新任务，也不处理队列中的任务，会终端正在处理任务的线程|
|**TIDYING**    |所有的任务都已经终止了，workerCount为0|
|**TERMINATED** |在terminated()方法执行完以后进入该状态|
其生命周期转换如下所示：
<br><img src=线程池生命周期.png><br>

## 任务执行机制
### 任务调度
任务调度是线程池的主要入口，当用户提交了一个任务，接下来这个任务将如何执行都是由这个阶段决定的。
首先，所有任务的调度都是由execute方法完成的，这部分完成的工作是：检查当前线程池的运行状态、运行线程数、运行策略，决定接下来执行的流程，是直接申请线程执行，或是缓冲到队列执行，或是直接拒绝该任务。其执行流程如下：
1. 首先检测线程池运行状态，如果不是running，则直接拒绝，线程池要保证在running的状态下执行任务。
2. 如果wordCount 小于 corePoolSize，则创建并启动一个线程来执行新提交的任务。
3. 如果workerCount 大于等于 corePoolSize，且线程池中的阻塞队列未满，则将该任务添加到阻塞队列中。
4. 如果workerCount 大于等于 corePoolSize && workerCount 小于 maximumPoolSize，且线程池内阻塞队列已满，则创建并启动一个线程来执行新提交的任务。
5. 如果workerCount 大于等于 maximumPoolSize，并且线程池内的阻塞队列已满，则根据拒绝策略来处理该任务，默认的处理方式是直接抛异常。
流程图如下所示:
<br><img src=img/任务调度流程.png><br>

### 任务缓冲
任务缓冲模块是线程池能够管理任务的核心部分，线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。
阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者场景，生产者是往队列中添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。
使用不同的阻塞队列可以实现不一样的任务存取策略，阻塞队列有下面几种类型：
<br><img src=阻塞队列.png><br>

### 任务申请
任务的执行有两种情况：一种是直接由新创建的线程执行。另一种是从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种情况是线程获取任务大多数的情况。
线程需要从任务缓存模块中不断地取任务执行，帮助线程从阻塞队列中获取任务，实现线程管理模块和任务管理模块之间的通信。这部分策略由getTask方法实现，执行流程如下：
<br><img src=img/获取任务流程.png><br>
```java
private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        // Are workers subject to culling?
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```